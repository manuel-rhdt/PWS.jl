<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · PathWeightSampling.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PathWeightSampling.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">PathWeightSampling.jl</a></li><li class="is-active"><a class="tocitem" href>Guide</a><ul class="internal"><li><a class="tocitem" href="#Setting-Up-the-System"><span>Setting Up the System</span></a></li><li><a class="tocitem" href="#Generating-and-Plotting-Trajectories"><span>Generating and Plotting Trajectories</span></a></li><li><a class="tocitem" href="#Computing-the-Trajectory-Mutual-Information"><span>Computing the Trajectory Mutual Information</span></a></li><li><a class="tocitem" href="#More-Advanced-Marginalization-Strategies"><span>More Advanced Marginalization Strategies</span></a></li><li><a class="tocitem" href="#API-Summary"><span>API Summary</span></a></li></ul></li><li><a class="tocitem" href="../systems/">Systems</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../marginalization/">Marginalization Strategies</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/manuel-rhdt/PathWeightSampling.jl/blob/master/docs/src/guide.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Guide"><a class="docs-heading-anchor" href="#Guide">Guide</a><a id="Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Guide" title="Permalink"></a></h1><p>In this section we will show step by step how PathWeightSampling.jl can be used to compute the mutual information for a simple model of gene expression.</p><h2 id="Setting-Up-the-System"><a class="docs-heading-anchor" href="#Setting-Up-the-System">Setting Up the System</a><a id="Setting-Up-the-System-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-Up-the-System" title="Permalink"></a></h2><p>The model considered in this example consists of four reactions:</p><pre><code class="nohighlight hljs">                κ
reaction 1:  ∅ ---&gt; S

                λ
reaction 2:  S ---&gt; ∅

                ρ
reaction 3:  S ---&gt; S + X

                μ
reaction 4:  X ---&gt; ∅</code></pre><p>The first two reactions specify the evolution of the input signal <code>S</code>, and last two reactions specify the evolution of the output <code>X</code>. Thus, both the input and output signal are modeled as a simple birth-death process, however the birth rate of <code>X</code> increases with higher copy numbers of  <code>S</code>.</p><p>The first step is to create the system that we are going to use. The simple gene expression model shown above is already included as an example in PathWeightSampling.jl and can be directly used as follows:</p><pre><code class="language-julia hljs">using PathWeightSampling

system = PathWeightSampling.gene_expression_system()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SimpleSystem with 4 reactions
Input variables: S(t)
Output variables: X(t)
Initial condition:
    S(t) = 50
    X(t) = 50
Parameters:
    κ = 50.0
    λ = 1.0
    ρ = 10.0
    μ = 10.0</code></pre><p>The result is a <code>system</code> consisting of the 4 reactions mentioned above and default values for the initial condition and the parameters that specify the reaction rates.</p><h2 id="Generating-and-Plotting-Trajectories"><a class="docs-heading-anchor" href="#Generating-and-Plotting-Trajectories">Generating and Plotting Trajectories</a><a id="Generating-and-Plotting-Trajectories-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-and-Plotting-Trajectories" title="Permalink"></a></h2><p>We can generate a <em>configuration</em> of this system. A configuration is a combination of an input trajectory and an output trajectories. Using <code>generate_configuration</code> we can create a configuration by first simulating an input trajectory and then use that input trajectory to simulate a corresponding output trajectory.</p><pre><code class="language-julia hljs">conf = generate_configuration(system)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PathWeightSampling.SXconfiguration{Int16, Int16, Float64}(PathWeightSampling.Trajectory{Int16, Float64, Vector{StaticArrays.SVector{1, Int16}}, Vector{Float64}, Vector{Int64}, StaticArrays.SVector{1, Symbol}, Nothing}(RecursiveArrayTools.VectorOfArray{Int16, 2, Vector{StaticArrays.SVector{1, Int16}}}(StaticArrays.SVector{1, Int16}[[50], [51], [52], [53], [54], [53], [54], [55], [56], [57]  …  [42], [41], [42], [43], [44], [43], [42], [43], [42], [41]]), [0.0016349370107310993, 0.002330674775910418, 0.0024509607378502994, 0.013560069493736913, 0.048866322263755396, 0.05206862638599316, 0.07211062737145782, 0.07592954995287646, 0.07651557316883853, 0.09696451253146078  …  1.917732724194694, 1.9213232289454514, 1.942630153856171, 1.9544975349857723, 1.9558056935355022, 1.980583846761693, 1.9837921939508991, 1.98650733008366, 1.9994024846500285, 2.0], [1, 1, 1, 1, 2, 1, 1, 1, 1, 1  …  2, 1, 1, 1, 2, 2, 1, 2, 2, 0], [Symbol(&quot;S(t)&quot;)], nothing), PathWeightSampling.Trajectory{Int16, Float64, Vector{StaticArrays.SVector{1, Int16}}, Vector{Float64}, Vector{Int64}, StaticArrays.SVector{1, Symbol}, Nothing}(RecursiveArrayTools.VectorOfArray{Int16, 2, Vector{StaticArrays.SVector{1, Int16}}}(StaticArrays.SVector{1, Int16}[[50], [49], [50], [51], [52], [53], [52], [51], [50], [49]  …  [40], [39], [38], [39], [40], [41], [40], [39], [38], [37]]), [7.356279966763837e-5, 0.000720181024813458, 0.0013969255405219996, 0.0015593303869488387, 0.0040172071215804125, 0.006324167952584257, 0.006946780562175995, 0.008046154593699114, 0.010067415132400462, 0.012845977107461425  …  1.990020232532902, 1.9915874871490864, 1.9921762455274439, 1.9923401130201048, 1.9928300451104286, 1.997250519713622, 1.9974476967714454, 1.9978836263852515, 1.999043103139589, 2.0], [4, 3, 3, 3, 3, 4, 4, 4, 4, 3  …  4, 4, 3, 3, 3, 4, 4, 4, 4, 0], [Symbol(&quot;X(t)&quot;)], nothing))</code></pre><p>Let us plot the generated configuration:</p><pre><code class="language-julia hljs">using Plots
plot(conf)</code></pre><p><img src="../plot1.svg" alt/></p><p>We see a plot of the generated input and output trajectories that make up the configuration.</p><p>The individual trajectories of the configuration can also be accessed directly:</p><pre><code class="language-julia hljs">input_traj = conf.s_traj
output_traj = conf.x_traj
p1 = plot(input_traj, label=&quot;input&quot;)
p2 = plot(output_traj, label=&quot;output&quot;)
plot(p1, p2, layout = (2, 1))</code></pre><p><img src="../plot2.svg" alt/></p><h2 id="Computing-the-Trajectory-Mutual-Information"><a class="docs-heading-anchor" href="#Computing-the-Trajectory-Mutual-Information">Computing the Trajectory Mutual Information</a><a id="Computing-the-Trajectory-Mutual-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-Trajectory-Mutual-Information" title="Permalink"></a></h2><p>For our system we can compute the trajectory mutual information straightforwardly. </p><pre><code class="language-julia hljs">result = PathWeightSampling.mutual_information(system, DirectMCEstimate(256), num_samples=100)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Progress:   2%|▌                          |  ETA: 0:06:25 ( 3.93  s/it)Progress:  30%|████████▏                  |  ETA: 0:00:23 ( 0.33  s/it)Progress:  44%|███████████▉               |  ETA: 0:00:14 ( 0.24  s/it)Progress:  59%|███████████████▉           |  ETA: 0:00:08 ( 0.19  s/it)Progress:  78%|█████████████████████      |  ETA: 0:00:04 ( 0.16  s/it)Progress:  91%|████████████████████████▋  |  ETA: 0:00:01 ( 0.14  s/it)Progress: 100%|███████████████████████████| Time: 0:00:13 ( 0.14  s/it)</code></pre><p>This performs a full PWS Monte Carlo simulation and displays a progress bar during the computation. Naturally, the <code>PWS.mutual_information</code> takes the <code>system</code> as its first argument. The second argument is an object specifying the <em>marginalization</em> algorithm to use for computing the marginal trajectory probability. Here we chose the simple brute-force <code>DirectMC</code> algorithm with <span>$M=256$</span> samples. Thus, we compute a &quot;Direct PWS&quot; estimate. The final keyword argument is the overall number of Monte Carlo samples to use for estimating the mutual information. This is the number of samples taken in the <em>outer</em> Monte Carlo simulation as opposed to the <span>$M=256$</span> samples taken in the <em>inner</em> Monte Carlo loop.</p><p><code>result</code> is a <code>DataFrame</code> containing the simulation results. We can display the individual Monte Carlo samples:</p><pre><code class="language-julia hljs">plot(
    system.dtimes,
    result.MutualInformation,
    color=:black,
    linewidth=0.2,
    legend=false,
    xlabel=&quot;trajectory duration&quot;,
    ylabel=&quot;mutual information (nats)&quot;
)</code></pre><p><img src="../plot3.svg" alt/></p><p>The final Monte Carlo estimate is simply the <code>mean</code> of the individual samples:</p><pre><code class="language-julia hljs">using Statistics
plot(
    system.dtimes,
    mean(result.MutualInformation),
    color=:black,
    linewidth=2,
    legend=false,
    xlabel=&quot;trajectory duration&quot;,
    ylabel=&quot;mutual information (nats)&quot;
)</code></pre><p><img src="../plot4.svg" alt/></p><p>Note that since we only used 100 MC samples the fluctuation of the result is relatively large. To judge the statistical error due to the number of Monte Carlo samples, we can additionally plot error bars. A common error measure in Monte Carlo simulations is the &quot;standard error of the mean&quot;, defined as the standard deviation divided by the square root of the number of samples. We use this method to draw error bars.</p><pre><code class="language-julia hljs">sem(x) = std(x) / sqrt(length(x))
plot(
    system.dtimes,
    mean(result.MutualInformation),
    yerr=sem(result.MutualInformation),
    color=:black,
    linewidth=2,
    legend=false,
    xlabel=&quot;trajectory duration&quot;,
    ylabel=&quot;mutual information (nats)&quot;
)</code></pre><p><img src="../plot5.svg" alt/></p><h2 id="More-Advanced-Marginalization-Strategies"><a class="docs-heading-anchor" href="#More-Advanced-Marginalization-Strategies">More Advanced Marginalization Strategies</a><a id="More-Advanced-Marginalization-Strategies-1"></a><a class="docs-heading-anchor-permalink" href="#More-Advanced-Marginalization-Strategies" title="Permalink"></a></h2><p>So far we computed the mutual information using the brute-force <em>Direct PWS</em> algorithm. However, we can choose a different approach to perform the marginalization integrals. To change the marginalization strategy we simply pass a different <code>algorithm</code> as the second argument of <code>PWS.mutual_information</code>. The possible choices for the marginalization strategy are</p><ul><li><code>DirectMCEstimate(m)</code>: The simple brute force marginalization using a Direct Monte Carlo estimate. The integer <code>m</code> specifies the number of samples to use per brute-force computation. This method works well for short trajectories but becomes exponentially worse for longer trajectories.</li><li><code>SMCEstimate(m)</code>: Improved computation of marginalization integrals using a sequential Monte Carlo technique (specifically using a particle filter). The integer <code>m</code> specifies the number of &quot;particles&quot; that are being propagated simultaneously. This method works much better than the <code>DirectMCEstimate</code> for long trajectories.</li><li><code>TIEstimate(burn_in, integration_nodes, num_samples)</code>: Use thermodynamic integration to compute the marginalization integrals. This will set up a number of MCMC simulations in path-space to perform the TI integral. <code>burn_in</code> specifies the number of initial samples from the MCMC simulation to be discarded, <code>integration_nodes</code> specifies the number of points to use in the Gaussian quadrature, and <code>num_samples</code> specifies the number of MCMC samples per integration node to generate.</li><li><code>AnnealingEstimate(subsample, num_temps, num_samples)</code>: Use annealed importance sampling to compute the marginalization integrals. This technique is very similar to thermodynamic integration and also uses MCMC simulations in path space. <code>subsample</code> specifies the number of Metropolis trials to perform before recording a new MCMC sample. <code>num_temps</code> sets how many different &quot;temperatures&quot; should be used for the annealing. <code>num_samples</code> is the number of MCMC samples to use per temperature setting.</li></ul><p>We can compute the mutual information using each of these strategies and compare the results:</p><pre><code class="language-julia hljs">strategies = [
    DirectMCEstimate(128),
    SMCEstimate(128),
    TIEstimate(0, 8, 16),
    # AnnealingEstimate(0, 128, 1)
]
results = [PathWeightSampling.mutual_information(system, strat, num_samples=100, progress=false) for strat in strategies]

plot()
for (strat, r) in zip(strategies, results)
    plot!(
        system.dtimes,
        mean(r.MutualInformation),
        label=PathWeightSampling.name(strat),
        xlabel=&quot;trajectory duration&quot;,
        ylabel=&quot;mutual information (nats)&quot;
    )
end</code></pre><p><img src="../plot6.svg" alt/></p><h2 id="API-Summary"><a class="docs-heading-anchor" href="#API-Summary">API Summary</a><a id="API-Summary-1"></a><a class="docs-heading-anchor-permalink" href="#API-Summary" title="Permalink"></a></h2><p>Thus, the core function to estimate the trajectory mutual information is <code>PathWeightSampling.mutual_information</code>. A complete description of its arguments and return value is given below.</p><article class="docstring"><header><a class="docstring-binding" id="PathWeightSampling.mutual_information" href="#PathWeightSampling.mutual_information"><code>PathWeightSampling.mutual_information</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mutual_information(system, algorithm; num_samples=1, progress=true)</code></pre><p>Perform a simulation to compute the mutual information between input and output trajectories of <code>system</code>. </p><p><strong>Arguments</strong></p><p>The required marginalization integrals to obtain the marginal probability <span>$\mathcal{P}[\bm{x}]$</span> are performed using the specified <code>algorithm</code>.</p><p>Overall, <code>num_samples</code> Monte Carlo samples are performed. For each individual sample, one or mupltiple marginalization operations need to be performed.</p><p>If <code>progress == true</code>, a progress bar will be shown during the computation.</p><p><strong>Returns</strong></p><p>Returns a <code>DataFrame</code> containing the results of the simulation. This resulting <code>DataFrame</code> has 3 columns. Assuming, the returned value has been named <code>result</code> the columns can be accessed by:</p><ul><li><code>result.MutualInformation</code>: A vector of vectors that contains the results of the simulation. Each element of the outer vector is the result of a single Monte Carlo sample. Each element is a vector containing the trajectory mutual information estimates for each time specified in <code>system.dtimes</code>.</li><li><code>result.TimeMarginal</code>: A vector containing, for each sample, the CPU time in seconds used for the computation of the marginal entropy.</li><li><code>result.TimeConditional</code>: A vector containing, for each sample, the CPU time in seconds used for the computation of the conditional entropy.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuel-rhdt/PathWeightSampling.jl/blob/6893adb25c0230419e3a40727392bc576b8d6c3a/src/marginal_strategies/strategies.jl#L23-L49">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« PathWeightSampling.jl</a><a class="docs-footer-nextpage" href="../systems/">Systems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.8 on <span class="colophon-date" title="Monday 23 May 2022 12:26">Monday 23 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
